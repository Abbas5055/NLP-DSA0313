import ply.lex as lex
import ply.yacc as yacc

# List of token names
tokens = (
    'AND', 'OR', 'NOT', 'IMPLIES',
    'FORALL', 'EXISTS',
    'LPAREN', 'RPAREN',
    'PREDICATE', 'VARIABLE', 'CONSTANT'
)

# Regular expression rules for simple tokens
t_AND = r'\^'
t_OR = r'v'
t_NOT = r'~'
t_IMPLIES = r'=>'
t_FORALL = r'\A'
t_EXISTS = r'\E'
t_LPAREN = r'\('
t_RPAREN = r'\)'

# Define a rule to match predicates
def t_PREDICATE(t):
    r'[A-Z][A-Za-z]*'
    return t

# Define a rule to match variables
def t_VARIABLE(t):
    r'[a-z][a-zA-Z0-9]*'
    return t

# Define a rule to match constants
def t_CONSTANT(t):
    r'[0-9]+'
    return t

# Define a rule for ignoring spaces
t_ignore = ' \t'

# Define a rule for tracking line numbers
def t_newline(t):
    r'\n+'
    t.lexer.lineno += len(t.value)

# Define a rule for handling errors
def t_error(t):
    print(f"Illegal character '{t.value[0]}'")
    t.lexer.skip(1)

# Build the lexer
lexer = lex.lex()

# Define precedence and associativity
precedence = (
    ('left', 'IMPLIES'),
    ('left', 'OR'),
    ('left', 'AND'),
    ('right', 'NOT'),
)

# Dictionary to hold expressions
expressions = {}

# Define the grammar rules for the parser
def p_expression_predicate(p):
    'expression : PREDICATE LPAREN args RPAREN'
    p[0] = f"{p[1]}({p[3]})"

def p_args_list(p):
    '''args : args COMMA term
            | term'''
    if len(p) == 2:
        p[0] = p[1]
    else:
        p[0] = f"{p[1]}, {p[3]}"

def p_term_variable(p):
    'term : VARIABLE'
    p[0] = p[1]

def p_term_constant(p):
    'term : CONSTANT'
    p[0] = p[1]

def p_expression_and(p):
    'expression : expression AND expression'
    p[0] = f"({p[1]} ^ {p[3]})"

def p_expression_or(p):
    'expression : expression OR expression'
    p[0] = f"({p[1]} v {p[3]})"

def p_expression_not(p):
    'expression : NOT expression'
    p[0] = f"~{p[2]}"

def p_expression_implies(p):
    'expression : expression IMPLIES expression'
    p[0] = f"({p[1]} => {p[3]})"

def p_expression_forall(p):
    'expression : FORALL VARIABLE LPAREN expression RPAREN'
    p[0] = f"A {p[2]}({p[4]})"

def p_expression_exists(p):
    'expression : EXISTS VARIABLE LPAREN expression RPAREN'
    p[0] = f"E {p[2]}({p[4]})"

def p_expression_group(p):
    'expression : LPAREN expression RPAREN'
    p[0] = p[2]

# Define an error rule for syntax errors
def p_error(p):
    print("Syntax error in input!")

# Build the parser
parser = yacc.yacc()

# Example logical expressions to parse
expressions = [
    "P(a, b)",
    "Q(x) ^ R(y)",
    "A x (P(x) => Q(x))",
    "E y (R(y) v S(y))",
    "~T(c)"
]

# Parse the expressions
for expr in expressions:
    result = parser.parse(expr)
    print(f"Input: {expr}\nParsed: {result}\n")
